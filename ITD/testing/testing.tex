\providecommand{\itd}{..}
\documentclass[../ITD.tex]{subfiles}

\begin{document}
    \chapter{Testing}\label{ch:testing}
    The testing has been done mostly as written in the DD. We perform two different types of tests to validate the behaviour of the complete system: front-end and back-end.
    \newline For more information we suggest to see the \href{https://github.com/fedy97/MorrealeMaddesInnocente/tree/master/safe_streets/test}{\emph{source code of the tests}}
    \section{Unit testing}\label{sec:unit-testing}
    The purpose of a unit test is to validate that each unit of the software performs as designed.
    \newline Every test is formed by three section:
    \begin{itemize}
        \item setup: in this section there is the setup and the instantiation of the elements useful during the test.
        \item run: the core section where functions are called.
        \item verify: throw the command \textit{expect()} there is the comparison between the results and the expected one.
    \end{itemize}
    We tests the main features: the building of the statistics, the violation query, the visualization of the reports on the map and the addition of a new report.

    \subsection{Build statistics}\label{subsec:build-statistics}
    We tests all the three types of statistics and for each type we build different test cases to validate different situation:
    \begin{itemize}
        \item effectiveness:
        \begin{enumerate}
            \item One report uploaded and not fined;
            \item One report uploaded and fined;
            \item Two reports uploaded: one fined and one not;
        \end{enumerate}
        \item daily reports:
        \begin{enumerate}
            \item Zero violation uploaded today;
            \item One violation uploaded today;
            \item one violation uploaded today and one yesterday;
        \end{enumerate}
        \item most committed violation:
        \begin{enumerate}
            \item Zero violation uploaded, no most committed violation;
            \item One violation uploaded is the most committed;
            \item Three violations uploaded of the same type are the most committed;
            \item Two violations uploaded of the same type and one of another type, the two ones are the most committed;
        \end{enumerate}
        All tests have the expected behaviour so performs as designed.
    \end{itemize}

    \subsection{Violation query}\label{subsec:violation-query}
    To make a violation query a generic user of the app must set different parameters: city, type of violation and the period in which it wants to retrieve the information (from date, to date).
    To analyze the behavior of violation query manager, we build a test case for each combination of the previous parameters.
    \begin{enumerate}
        \item One report respects all the bounds of the query;
        \item Two report respects the bounds of the query (no bounds on city);
        \item Two report respects the bounds of the query (no bounds on violation);
        \item Two report respects the bounds of the query (no bounds on timeTo);
        \item Two report respects the bounds of the query (no bounds on timeFrom);
        \item Two report respects the bounds of the query (no bounds on timeFrom and timeTo);
        \item Two report respects the bounds of the query (no bounds on violation and timeTo);
        \item Two report respects the bounds of the query (no bounds on violation and timeFrom);
        \item Two report respects the bounds of the query (no bounds on violation and timeFrom and timeTo);
        \item Two report respects the bounds of the query (no bounds on city and timeTo);
        \item Two report respects the bounds of the query (no bounds on city and timeFrom);
        \item Two report respects the bounds of the query (no bounds on city and timeFrom and timeTo);
        \item Two report respects the bounds of the query (no bounds on city and violation);
        \item Two report respects the bounds of the query (no bounds on city and violation and timeTo);
        \item Two report respects the bounds of the query (no bounds on city and violation and timeFrom);
        \item Two report respects the bounds of the query (no bounds on city and violation and timeFrom and timeTo);
    \end{enumerate}
    All tests have the expected behaviour so performs as designed.

    \subsection{Report visualization on map}\label{subsec:report-visualization-on-map}
    We tested the interaction between the reports stored and the reports on the map; in particular we tested the bound on the visualization of the reports of the last 24 hours (today).
    \begin{enumerate}
        \item No violation uploaded, no violation on the map;
        \item Two violation not fined today, two violation on the map;
        \item Two report not fined yesterday, zero violation on the map;
        \item Report uploaded yesterday, zero violation on the map;
        \item Two reports,only one today, one violation on the map;
        \item Two report on same position, two report on the map;
    \end{enumerate}
    All tests set the expected number of reports in the correct position.

    \subsection{Add a new report}\label{subsec:add-a-new-report}
    In this group of tests we validate the behavior of the app when it receives a new report.
    In particular the addition of a report already uploaded by someone.
    \begin{enumerate}
        \item Similar report don't exist;
        \item Report with same location and day;
        \item Report with same location and violation;
    \end{enumerate}
    Test case 1 is the base case so the report is added.
    \newline Test cases 2 and 3 rejects the addition of a new report because there is already one report in the database with same location and day/violation.


    \section{Widget testing}\label{sec:widget-testing}
    A widget test validate a single widget.
    The goal of a widget test is to verify that the widgetâ€™s UI looks and interacts as expected so they can actually test the UI.

    \subsection{Login}\label{subsec:login}
    \begin{enumerate}
        \item Email, password and button are found;
        \item It validates empty email and password;
        \item It calls sign in method when email and password is entered;
    \end{enumerate}

    \subsection{Sign up}\label{subsec:sign-up}
    \begin{enumerate}
        \item Email, password, confirm password and button are found;
        \item It validates empty fields;
        \item It calls sign up method when email and password is entered,
    \end{enumerate}

    \section{Integration testing}\label{sec:integration-testing}
\end{document}